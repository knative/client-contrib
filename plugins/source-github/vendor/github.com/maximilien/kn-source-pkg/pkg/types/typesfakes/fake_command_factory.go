// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"

	"github.com/maximilien/kn-source-pkg/pkg/types"
	"github.com/spf13/cobra"
)

type FakeCommandFactory struct {
	CreateCommandStub        func() *cobra.Command
	createCommandMutex       sync.RWMutex
	createCommandArgsForCall []struct {
	}
	createCommandReturns struct {
		result1 *cobra.Command
	}
	createCommandReturnsOnCall map[int]struct {
		result1 *cobra.Command
	}
	DeleteCommandStub        func() *cobra.Command
	deleteCommandMutex       sync.RWMutex
	deleteCommandArgsForCall []struct {
	}
	deleteCommandReturns struct {
		result1 *cobra.Command
	}
	deleteCommandReturnsOnCall map[int]struct {
		result1 *cobra.Command
	}
	DescribeCommandStub        func() *cobra.Command
	describeCommandMutex       sync.RWMutex
	describeCommandArgsForCall []struct {
	}
	describeCommandReturns struct {
		result1 *cobra.Command
	}
	describeCommandReturnsOnCall map[int]struct {
		result1 *cobra.Command
	}
	KnSourceFactoryStub        func() types.KnSourceFactory
	knSourceFactoryMutex       sync.RWMutex
	knSourceFactoryArgsForCall []struct {
	}
	knSourceFactoryReturns struct {
		result1 types.KnSourceFactory
	}
	knSourceFactoryReturnsOnCall map[int]struct {
		result1 types.KnSourceFactory
	}
	SourceCommandStub        func() *cobra.Command
	sourceCommandMutex       sync.RWMutex
	sourceCommandArgsForCall []struct {
	}
	sourceCommandReturns struct {
		result1 *cobra.Command
	}
	sourceCommandReturnsOnCall map[int]struct {
		result1 *cobra.Command
	}
	UpdateCommandStub        func() *cobra.Command
	updateCommandMutex       sync.RWMutex
	updateCommandArgsForCall []struct {
	}
	updateCommandReturns struct {
		result1 *cobra.Command
	}
	updateCommandReturnsOnCall map[int]struct {
		result1 *cobra.Command
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCommandFactory) CreateCommand() *cobra.Command {
	fake.createCommandMutex.Lock()
	ret, specificReturn := fake.createCommandReturnsOnCall[len(fake.createCommandArgsForCall)]
	fake.createCommandArgsForCall = append(fake.createCommandArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateCommand", []interface{}{})
	fake.createCommandMutex.Unlock()
	if fake.CreateCommandStub != nil {
		return fake.CreateCommandStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createCommandReturns
	return fakeReturns.result1
}

func (fake *FakeCommandFactory) CreateCommandCallCount() int {
	fake.createCommandMutex.RLock()
	defer fake.createCommandMutex.RUnlock()
	return len(fake.createCommandArgsForCall)
}

func (fake *FakeCommandFactory) CreateCommandCalls(stub func() *cobra.Command) {
	fake.createCommandMutex.Lock()
	defer fake.createCommandMutex.Unlock()
	fake.CreateCommandStub = stub
}

func (fake *FakeCommandFactory) CreateCommandReturns(result1 *cobra.Command) {
	fake.createCommandMutex.Lock()
	defer fake.createCommandMutex.Unlock()
	fake.CreateCommandStub = nil
	fake.createCommandReturns = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) CreateCommandReturnsOnCall(i int, result1 *cobra.Command) {
	fake.createCommandMutex.Lock()
	defer fake.createCommandMutex.Unlock()
	fake.CreateCommandStub = nil
	if fake.createCommandReturnsOnCall == nil {
		fake.createCommandReturnsOnCall = make(map[int]struct {
			result1 *cobra.Command
		})
	}
	fake.createCommandReturnsOnCall[i] = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) DeleteCommand() *cobra.Command {
	fake.deleteCommandMutex.Lock()
	ret, specificReturn := fake.deleteCommandReturnsOnCall[len(fake.deleteCommandArgsForCall)]
	fake.deleteCommandArgsForCall = append(fake.deleteCommandArgsForCall, struct {
	}{})
	fake.recordInvocation("DeleteCommand", []interface{}{})
	fake.deleteCommandMutex.Unlock()
	if fake.DeleteCommandStub != nil {
		return fake.DeleteCommandStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteCommandReturns
	return fakeReturns.result1
}

func (fake *FakeCommandFactory) DeleteCommandCallCount() int {
	fake.deleteCommandMutex.RLock()
	defer fake.deleteCommandMutex.RUnlock()
	return len(fake.deleteCommandArgsForCall)
}

func (fake *FakeCommandFactory) DeleteCommandCalls(stub func() *cobra.Command) {
	fake.deleteCommandMutex.Lock()
	defer fake.deleteCommandMutex.Unlock()
	fake.DeleteCommandStub = stub
}

func (fake *FakeCommandFactory) DeleteCommandReturns(result1 *cobra.Command) {
	fake.deleteCommandMutex.Lock()
	defer fake.deleteCommandMutex.Unlock()
	fake.DeleteCommandStub = nil
	fake.deleteCommandReturns = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) DeleteCommandReturnsOnCall(i int, result1 *cobra.Command) {
	fake.deleteCommandMutex.Lock()
	defer fake.deleteCommandMutex.Unlock()
	fake.DeleteCommandStub = nil
	if fake.deleteCommandReturnsOnCall == nil {
		fake.deleteCommandReturnsOnCall = make(map[int]struct {
			result1 *cobra.Command
		})
	}
	fake.deleteCommandReturnsOnCall[i] = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) DescribeCommand() *cobra.Command {
	fake.describeCommandMutex.Lock()
	ret, specificReturn := fake.describeCommandReturnsOnCall[len(fake.describeCommandArgsForCall)]
	fake.describeCommandArgsForCall = append(fake.describeCommandArgsForCall, struct {
	}{})
	fake.recordInvocation("DescribeCommand", []interface{}{})
	fake.describeCommandMutex.Unlock()
	if fake.DescribeCommandStub != nil {
		return fake.DescribeCommandStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.describeCommandReturns
	return fakeReturns.result1
}

func (fake *FakeCommandFactory) DescribeCommandCallCount() int {
	fake.describeCommandMutex.RLock()
	defer fake.describeCommandMutex.RUnlock()
	return len(fake.describeCommandArgsForCall)
}

func (fake *FakeCommandFactory) DescribeCommandCalls(stub func() *cobra.Command) {
	fake.describeCommandMutex.Lock()
	defer fake.describeCommandMutex.Unlock()
	fake.DescribeCommandStub = stub
}

func (fake *FakeCommandFactory) DescribeCommandReturns(result1 *cobra.Command) {
	fake.describeCommandMutex.Lock()
	defer fake.describeCommandMutex.Unlock()
	fake.DescribeCommandStub = nil
	fake.describeCommandReturns = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) DescribeCommandReturnsOnCall(i int, result1 *cobra.Command) {
	fake.describeCommandMutex.Lock()
	defer fake.describeCommandMutex.Unlock()
	fake.DescribeCommandStub = nil
	if fake.describeCommandReturnsOnCall == nil {
		fake.describeCommandReturnsOnCall = make(map[int]struct {
			result1 *cobra.Command
		})
	}
	fake.describeCommandReturnsOnCall[i] = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) KnSourceFactory() types.KnSourceFactory {
	fake.knSourceFactoryMutex.Lock()
	ret, specificReturn := fake.knSourceFactoryReturnsOnCall[len(fake.knSourceFactoryArgsForCall)]
	fake.knSourceFactoryArgsForCall = append(fake.knSourceFactoryArgsForCall, struct {
	}{})
	fake.recordInvocation("KnSourceFactory", []interface{}{})
	fake.knSourceFactoryMutex.Unlock()
	if fake.KnSourceFactoryStub != nil {
		return fake.KnSourceFactoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.knSourceFactoryReturns
	return fakeReturns.result1
}

func (fake *FakeCommandFactory) KnSourceFactoryCallCount() int {
	fake.knSourceFactoryMutex.RLock()
	defer fake.knSourceFactoryMutex.RUnlock()
	return len(fake.knSourceFactoryArgsForCall)
}

func (fake *FakeCommandFactory) KnSourceFactoryCalls(stub func() types.KnSourceFactory) {
	fake.knSourceFactoryMutex.Lock()
	defer fake.knSourceFactoryMutex.Unlock()
	fake.KnSourceFactoryStub = stub
}

func (fake *FakeCommandFactory) KnSourceFactoryReturns(result1 types.KnSourceFactory) {
	fake.knSourceFactoryMutex.Lock()
	defer fake.knSourceFactoryMutex.Unlock()
	fake.KnSourceFactoryStub = nil
	fake.knSourceFactoryReturns = struct {
		result1 types.KnSourceFactory
	}{result1}
}

func (fake *FakeCommandFactory) KnSourceFactoryReturnsOnCall(i int, result1 types.KnSourceFactory) {
	fake.knSourceFactoryMutex.Lock()
	defer fake.knSourceFactoryMutex.Unlock()
	fake.KnSourceFactoryStub = nil
	if fake.knSourceFactoryReturnsOnCall == nil {
		fake.knSourceFactoryReturnsOnCall = make(map[int]struct {
			result1 types.KnSourceFactory
		})
	}
	fake.knSourceFactoryReturnsOnCall[i] = struct {
		result1 types.KnSourceFactory
	}{result1}
}

func (fake *FakeCommandFactory) SourceCommand() *cobra.Command {
	fake.sourceCommandMutex.Lock()
	ret, specificReturn := fake.sourceCommandReturnsOnCall[len(fake.sourceCommandArgsForCall)]
	fake.sourceCommandArgsForCall = append(fake.sourceCommandArgsForCall, struct {
	}{})
	fake.recordInvocation("SourceCommand", []interface{}{})
	fake.sourceCommandMutex.Unlock()
	if fake.SourceCommandStub != nil {
		return fake.SourceCommandStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sourceCommandReturns
	return fakeReturns.result1
}

func (fake *FakeCommandFactory) SourceCommandCallCount() int {
	fake.sourceCommandMutex.RLock()
	defer fake.sourceCommandMutex.RUnlock()
	return len(fake.sourceCommandArgsForCall)
}

func (fake *FakeCommandFactory) SourceCommandCalls(stub func() *cobra.Command) {
	fake.sourceCommandMutex.Lock()
	defer fake.sourceCommandMutex.Unlock()
	fake.SourceCommandStub = stub
}

func (fake *FakeCommandFactory) SourceCommandReturns(result1 *cobra.Command) {
	fake.sourceCommandMutex.Lock()
	defer fake.sourceCommandMutex.Unlock()
	fake.SourceCommandStub = nil
	fake.sourceCommandReturns = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) SourceCommandReturnsOnCall(i int, result1 *cobra.Command) {
	fake.sourceCommandMutex.Lock()
	defer fake.sourceCommandMutex.Unlock()
	fake.SourceCommandStub = nil
	if fake.sourceCommandReturnsOnCall == nil {
		fake.sourceCommandReturnsOnCall = make(map[int]struct {
			result1 *cobra.Command
		})
	}
	fake.sourceCommandReturnsOnCall[i] = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) UpdateCommand() *cobra.Command {
	fake.updateCommandMutex.Lock()
	ret, specificReturn := fake.updateCommandReturnsOnCall[len(fake.updateCommandArgsForCall)]
	fake.updateCommandArgsForCall = append(fake.updateCommandArgsForCall, struct {
	}{})
	fake.recordInvocation("UpdateCommand", []interface{}{})
	fake.updateCommandMutex.Unlock()
	if fake.UpdateCommandStub != nil {
		return fake.UpdateCommandStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateCommandReturns
	return fakeReturns.result1
}

func (fake *FakeCommandFactory) UpdateCommandCallCount() int {
	fake.updateCommandMutex.RLock()
	defer fake.updateCommandMutex.RUnlock()
	return len(fake.updateCommandArgsForCall)
}

func (fake *FakeCommandFactory) UpdateCommandCalls(stub func() *cobra.Command) {
	fake.updateCommandMutex.Lock()
	defer fake.updateCommandMutex.Unlock()
	fake.UpdateCommandStub = stub
}

func (fake *FakeCommandFactory) UpdateCommandReturns(result1 *cobra.Command) {
	fake.updateCommandMutex.Lock()
	defer fake.updateCommandMutex.Unlock()
	fake.UpdateCommandStub = nil
	fake.updateCommandReturns = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) UpdateCommandReturnsOnCall(i int, result1 *cobra.Command) {
	fake.updateCommandMutex.Lock()
	defer fake.updateCommandMutex.Unlock()
	fake.UpdateCommandStub = nil
	if fake.updateCommandReturnsOnCall == nil {
		fake.updateCommandReturnsOnCall = make(map[int]struct {
			result1 *cobra.Command
		})
	}
	fake.updateCommandReturnsOnCall[i] = struct {
		result1 *cobra.Command
	}{result1}
}

func (fake *FakeCommandFactory) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createCommandMutex.RLock()
	defer fake.createCommandMutex.RUnlock()
	fake.deleteCommandMutex.RLock()
	defer fake.deleteCommandMutex.RUnlock()
	fake.describeCommandMutex.RLock()
	defer fake.describeCommandMutex.RUnlock()
	fake.knSourceFactoryMutex.RLock()
	defer fake.knSourceFactoryMutex.RUnlock()
	fake.sourceCommandMutex.RLock()
	defer fake.sourceCommandMutex.RUnlock()
	fake.updateCommandMutex.RLock()
	defer fake.updateCommandMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCommandFactory) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.CommandFactory = new(FakeCommandFactory)
