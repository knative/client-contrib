// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"

	"github.com/maximilien/kn-source-pkg/pkg/types"
	"github.com/spf13/pflag"
)

type FakeFlagsFactory struct {
	CreateFlagsStub        func() *pflag.FlagSet
	createFlagsMutex       sync.RWMutex
	createFlagsArgsForCall []struct {
	}
	createFlagsReturns struct {
		result1 *pflag.FlagSet
	}
	createFlagsReturnsOnCall map[int]struct {
		result1 *pflag.FlagSet
	}
	DeleteFlagsStub        func() *pflag.FlagSet
	deleteFlagsMutex       sync.RWMutex
	deleteFlagsArgsForCall []struct {
	}
	deleteFlagsReturns struct {
		result1 *pflag.FlagSet
	}
	deleteFlagsReturnsOnCall map[int]struct {
		result1 *pflag.FlagSet
	}
	DescribeFlagsStub        func() *pflag.FlagSet
	describeFlagsMutex       sync.RWMutex
	describeFlagsArgsForCall []struct {
	}
	describeFlagsReturns struct {
		result1 *pflag.FlagSet
	}
	describeFlagsReturnsOnCall map[int]struct {
		result1 *pflag.FlagSet
	}
	KnSourceFactoryStub        func() types.KnSourceFactory
	knSourceFactoryMutex       sync.RWMutex
	knSourceFactoryArgsForCall []struct {
	}
	knSourceFactoryReturns struct {
		result1 types.KnSourceFactory
	}
	knSourceFactoryReturnsOnCall map[int]struct {
		result1 types.KnSourceFactory
	}
	UpdateFlagsStub        func() *pflag.FlagSet
	updateFlagsMutex       sync.RWMutex
	updateFlagsArgsForCall []struct {
	}
	updateFlagsReturns struct {
		result1 *pflag.FlagSet
	}
	updateFlagsReturnsOnCall map[int]struct {
		result1 *pflag.FlagSet
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeFlagsFactory) CreateFlags() *pflag.FlagSet {
	fake.createFlagsMutex.Lock()
	ret, specificReturn := fake.createFlagsReturnsOnCall[len(fake.createFlagsArgsForCall)]
	fake.createFlagsArgsForCall = append(fake.createFlagsArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateFlags", []interface{}{})
	fake.createFlagsMutex.Unlock()
	if fake.CreateFlagsStub != nil {
		return fake.CreateFlagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.createFlagsReturns
	return fakeReturns.result1
}

func (fake *FakeFlagsFactory) CreateFlagsCallCount() int {
	fake.createFlagsMutex.RLock()
	defer fake.createFlagsMutex.RUnlock()
	return len(fake.createFlagsArgsForCall)
}

func (fake *FakeFlagsFactory) CreateFlagsCalls(stub func() *pflag.FlagSet) {
	fake.createFlagsMutex.Lock()
	defer fake.createFlagsMutex.Unlock()
	fake.CreateFlagsStub = stub
}

func (fake *FakeFlagsFactory) CreateFlagsReturns(result1 *pflag.FlagSet) {
	fake.createFlagsMutex.Lock()
	defer fake.createFlagsMutex.Unlock()
	fake.CreateFlagsStub = nil
	fake.createFlagsReturns = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) CreateFlagsReturnsOnCall(i int, result1 *pflag.FlagSet) {
	fake.createFlagsMutex.Lock()
	defer fake.createFlagsMutex.Unlock()
	fake.CreateFlagsStub = nil
	if fake.createFlagsReturnsOnCall == nil {
		fake.createFlagsReturnsOnCall = make(map[int]struct {
			result1 *pflag.FlagSet
		})
	}
	fake.createFlagsReturnsOnCall[i] = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) DeleteFlags() *pflag.FlagSet {
	fake.deleteFlagsMutex.Lock()
	ret, specificReturn := fake.deleteFlagsReturnsOnCall[len(fake.deleteFlagsArgsForCall)]
	fake.deleteFlagsArgsForCall = append(fake.deleteFlagsArgsForCall, struct {
	}{})
	fake.recordInvocation("DeleteFlags", []interface{}{})
	fake.deleteFlagsMutex.Unlock()
	if fake.DeleteFlagsStub != nil {
		return fake.DeleteFlagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteFlagsReturns
	return fakeReturns.result1
}

func (fake *FakeFlagsFactory) DeleteFlagsCallCount() int {
	fake.deleteFlagsMutex.RLock()
	defer fake.deleteFlagsMutex.RUnlock()
	return len(fake.deleteFlagsArgsForCall)
}

func (fake *FakeFlagsFactory) DeleteFlagsCalls(stub func() *pflag.FlagSet) {
	fake.deleteFlagsMutex.Lock()
	defer fake.deleteFlagsMutex.Unlock()
	fake.DeleteFlagsStub = stub
}

func (fake *FakeFlagsFactory) DeleteFlagsReturns(result1 *pflag.FlagSet) {
	fake.deleteFlagsMutex.Lock()
	defer fake.deleteFlagsMutex.Unlock()
	fake.DeleteFlagsStub = nil
	fake.deleteFlagsReturns = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) DeleteFlagsReturnsOnCall(i int, result1 *pflag.FlagSet) {
	fake.deleteFlagsMutex.Lock()
	defer fake.deleteFlagsMutex.Unlock()
	fake.DeleteFlagsStub = nil
	if fake.deleteFlagsReturnsOnCall == nil {
		fake.deleteFlagsReturnsOnCall = make(map[int]struct {
			result1 *pflag.FlagSet
		})
	}
	fake.deleteFlagsReturnsOnCall[i] = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) DescribeFlags() *pflag.FlagSet {
	fake.describeFlagsMutex.Lock()
	ret, specificReturn := fake.describeFlagsReturnsOnCall[len(fake.describeFlagsArgsForCall)]
	fake.describeFlagsArgsForCall = append(fake.describeFlagsArgsForCall, struct {
	}{})
	fake.recordInvocation("DescribeFlags", []interface{}{})
	fake.describeFlagsMutex.Unlock()
	if fake.DescribeFlagsStub != nil {
		return fake.DescribeFlagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.describeFlagsReturns
	return fakeReturns.result1
}

func (fake *FakeFlagsFactory) DescribeFlagsCallCount() int {
	fake.describeFlagsMutex.RLock()
	defer fake.describeFlagsMutex.RUnlock()
	return len(fake.describeFlagsArgsForCall)
}

func (fake *FakeFlagsFactory) DescribeFlagsCalls(stub func() *pflag.FlagSet) {
	fake.describeFlagsMutex.Lock()
	defer fake.describeFlagsMutex.Unlock()
	fake.DescribeFlagsStub = stub
}

func (fake *FakeFlagsFactory) DescribeFlagsReturns(result1 *pflag.FlagSet) {
	fake.describeFlagsMutex.Lock()
	defer fake.describeFlagsMutex.Unlock()
	fake.DescribeFlagsStub = nil
	fake.describeFlagsReturns = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) DescribeFlagsReturnsOnCall(i int, result1 *pflag.FlagSet) {
	fake.describeFlagsMutex.Lock()
	defer fake.describeFlagsMutex.Unlock()
	fake.DescribeFlagsStub = nil
	if fake.describeFlagsReturnsOnCall == nil {
		fake.describeFlagsReturnsOnCall = make(map[int]struct {
			result1 *pflag.FlagSet
		})
	}
	fake.describeFlagsReturnsOnCall[i] = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) KnSourceFactory() types.KnSourceFactory {
	fake.knSourceFactoryMutex.Lock()
	ret, specificReturn := fake.knSourceFactoryReturnsOnCall[len(fake.knSourceFactoryArgsForCall)]
	fake.knSourceFactoryArgsForCall = append(fake.knSourceFactoryArgsForCall, struct {
	}{})
	fake.recordInvocation("KnSourceFactory", []interface{}{})
	fake.knSourceFactoryMutex.Unlock()
	if fake.KnSourceFactoryStub != nil {
		return fake.KnSourceFactoryStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.knSourceFactoryReturns
	return fakeReturns.result1
}

func (fake *FakeFlagsFactory) KnSourceFactoryCallCount() int {
	fake.knSourceFactoryMutex.RLock()
	defer fake.knSourceFactoryMutex.RUnlock()
	return len(fake.knSourceFactoryArgsForCall)
}

func (fake *FakeFlagsFactory) KnSourceFactoryCalls(stub func() types.KnSourceFactory) {
	fake.knSourceFactoryMutex.Lock()
	defer fake.knSourceFactoryMutex.Unlock()
	fake.KnSourceFactoryStub = stub
}

func (fake *FakeFlagsFactory) KnSourceFactoryReturns(result1 types.KnSourceFactory) {
	fake.knSourceFactoryMutex.Lock()
	defer fake.knSourceFactoryMutex.Unlock()
	fake.KnSourceFactoryStub = nil
	fake.knSourceFactoryReturns = struct {
		result1 types.KnSourceFactory
	}{result1}
}

func (fake *FakeFlagsFactory) KnSourceFactoryReturnsOnCall(i int, result1 types.KnSourceFactory) {
	fake.knSourceFactoryMutex.Lock()
	defer fake.knSourceFactoryMutex.Unlock()
	fake.KnSourceFactoryStub = nil
	if fake.knSourceFactoryReturnsOnCall == nil {
		fake.knSourceFactoryReturnsOnCall = make(map[int]struct {
			result1 types.KnSourceFactory
		})
	}
	fake.knSourceFactoryReturnsOnCall[i] = struct {
		result1 types.KnSourceFactory
	}{result1}
}

func (fake *FakeFlagsFactory) UpdateFlags() *pflag.FlagSet {
	fake.updateFlagsMutex.Lock()
	ret, specificReturn := fake.updateFlagsReturnsOnCall[len(fake.updateFlagsArgsForCall)]
	fake.updateFlagsArgsForCall = append(fake.updateFlagsArgsForCall, struct {
	}{})
	fake.recordInvocation("UpdateFlags", []interface{}{})
	fake.updateFlagsMutex.Unlock()
	if fake.UpdateFlagsStub != nil {
		return fake.UpdateFlagsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.updateFlagsReturns
	return fakeReturns.result1
}

func (fake *FakeFlagsFactory) UpdateFlagsCallCount() int {
	fake.updateFlagsMutex.RLock()
	defer fake.updateFlagsMutex.RUnlock()
	return len(fake.updateFlagsArgsForCall)
}

func (fake *FakeFlagsFactory) UpdateFlagsCalls(stub func() *pflag.FlagSet) {
	fake.updateFlagsMutex.Lock()
	defer fake.updateFlagsMutex.Unlock()
	fake.UpdateFlagsStub = stub
}

func (fake *FakeFlagsFactory) UpdateFlagsReturns(result1 *pflag.FlagSet) {
	fake.updateFlagsMutex.Lock()
	defer fake.updateFlagsMutex.Unlock()
	fake.UpdateFlagsStub = nil
	fake.updateFlagsReturns = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) UpdateFlagsReturnsOnCall(i int, result1 *pflag.FlagSet) {
	fake.updateFlagsMutex.Lock()
	defer fake.updateFlagsMutex.Unlock()
	fake.UpdateFlagsStub = nil
	if fake.updateFlagsReturnsOnCall == nil {
		fake.updateFlagsReturnsOnCall = make(map[int]struct {
			result1 *pflag.FlagSet
		})
	}
	fake.updateFlagsReturnsOnCall[i] = struct {
		result1 *pflag.FlagSet
	}{result1}
}

func (fake *FakeFlagsFactory) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createFlagsMutex.RLock()
	defer fake.createFlagsMutex.RUnlock()
	fake.deleteFlagsMutex.RLock()
	defer fake.deleteFlagsMutex.RUnlock()
	fake.describeFlagsMutex.RLock()
	defer fake.describeFlagsMutex.RUnlock()
	fake.knSourceFactoryMutex.RLock()
	defer fake.knSourceFactoryMutex.RUnlock()
	fake.updateFlagsMutex.RLock()
	defer fake.updateFlagsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeFlagsFactory) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.FlagsFactory = new(FakeFlagsFactory)
